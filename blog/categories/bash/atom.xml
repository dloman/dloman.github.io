<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: bash | Hopeless Lomantic]]></title>
  <link href="http://danloman.org/blog/categories/bash/atom.xml" rel="self"/>
  <link href="http://danloman.org/"/>
  <updated>2015-03-12T13:21:55-07:00</updated>
  <id>http://danloman.org/</id>
  <author>
    <name><![CDATA[Dan Loman]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Password Manager]]></title>
    <link href="http://danloman.org/blog/2014/07/14/password-manager/"/>
    <updated>2014-07-14T22:22:00-07:00</updated>
    <id>http://danloman.org/blog/2014/07/14/password-manager</id>
    <content type="html"><![CDATA[<p>Passwords are annoying.
I am not very good at remembering passwords and I am even worse at remembering strong passwords.
While I am fully aware of how insecure it is to reuse passwords,
it is so much easier that I usually ending up doing it in practice.
There are several solutions to this problem, the most common being storing passwords in an encrypted volume
or using an online password manager. I don&rsquo;t like either of those solutions because all of your passwords are being stored on disk on even worse on someone else&rsquo;s machine. So I built my own password generator using hash functions.</p>

<!-- more -->


<h2>Hash Function</h2>

<p>according to wikipedia</p>

<blockquote><p>&ldquo;a <a href=http://en.wikipedia.org/wiki/Cryptographic_hash_function> cryptographic hash function </a>
is a function which generates fixed-length output data that acts as a shortened reference to the original
data which is considered practically impossible to invert, that is, to recreate the input data from its hash value alone.&rdquo;</p></blockquote>

<p>This impossibility to invert means that even if my password gets leaked it is impossible to get the string from which my password was generated.
And as long as there are no collisions in the hash function it is guaranteed that all password + website combinations will generate a unique alpha numeric string.</p>

<h2>What my app does</h2>

<p>The application is quite simple.
It takes input from the user for a password and website.
It then concatenates those strings together and feeds that string as an input to the SHA1 hash function.
The first 10 digits of the output of the SHA1 function are then copied into the copy/paste buffer
of the system to be pasted into the password field for the site.</p>

<h2>The Code</h2>

<pre><code>#!/bin/bash
printf "Enter Password Please: "
stty -echo
read pass
printf "\nEnter Website Please: "
stty echo
read site
printf '\n'
echo ${pass/ /}${site/ /} |openssl sha1 |cut -c 10-19|xclip -selection c
history -d $((HISTCMD-0))
exit
</code></pre>

<h2>Cross Platform</h2>

<p>I originally wrote this app as a bash script and used it for almost a year that way.
The issue with this was when i was on my phone I had to log in via ssh run the command
and then copy from the terminal app.
This was a pain, and since this was a very simple application I figured it would be a
good project to learn android development with.
So I wrote an android application which does the exact same thing as the bash script.
Its not the prettiest app in the world but it works great.
You can check out the android app on my
<a href=http://github.com/dloman/PasswordManager.git> Github Page </a></p>

<p>Let me know if you have any improvements, questions, gaping security holes, or comments!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[update to cli script]]></title>
    <link href="http://danloman.org/blog/2014/07/13/update-to-cli-script/"/>
    <updated>2014-07-13T04:45:00-07:00</updated>
    <id>http://danloman.org/blog/2014/07/13/update-to-cli-script</id>
    <content type="html"><![CDATA[<p>A while back I wrote a <a href=http://danloman.org/blog/2013/12/19/alternative-for-quick-cli-filesystem-navagation-shortcutting/> little bash function</a>
which automatically creates bash aliases for moving around in commonly used directories in my file system.
This worked awesomely until one day I was working on a machine where I was not my normal username.
The root of my problem was that I use a synced bash_alias file, so  all of my bash_alias files are identical across multiple machines and users.
normal this works great, but when I used the alias and moved to edit files in what i thought was /home/differentuser/Source/ I was acutally editing /home/dloman/Source/.
I didnt realize this mistake and got very confused when I tried to save my edits and was unable to.
Needless to say it took me awhile of flailing about, thinking I was completly insane until I figured out what was happening.
I edited the my mark function with this sed command to replace the expanded <code>$HOME</code> path with the actual string <code>$HOME</code>. The updated command is as follows:</p>

<pre><code>function mark
{
  echo "alias $1='cd $(pwd)'" | sed -e "s:$HOME:\$HOME:g" &gt;&gt; ~/Dropbox/Config/bash_aliases ;
  source ~/Dropbox/Config/bash_aliases
}
</code></pre>

<p>Now my bash_aliases file is sharable regardless of which user I am logged in as.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Alternative for quick cli filesystem navagation shortcutting]]></title>
    <link href="http://danloman.org/blog/2013/12/19/alternative-for-quick-cli-filesystem-navagation-shortcutting/"/>
    <updated>2013-12-19T22:00:00-08:00</updated>
    <id>http://danloman.org/blog/2013/12/19/alternative-for-quick-cli-filesystem-navagation-shortcutting</id>
    <content type="html"><![CDATA[<p>I saw this great <a href="http://jeroenjanssens.com/2013/08/16/quickly-navigate-your-filesystem-from-the-command-line.html"> blog post</a> about an easy way to create and remove shortcuts for commandline navagation to often used directories.
In the past I would often manually make bash aliases for commonly used directories, so I was psyched to automate this. I much prefer just typing the <code>DirName</code> instead of the <code>jump DirName</code> used in Jeroen&rsquo;s version, so I modified his commands with my own.
Here are the commands I came up with.</p>

<pre><code>function mark {
  echo "alias $1='cd $(pwd)'" &gt;&gt; ~/Dropbox/Config/bash_aliases ; source ~/Dropbox/Config/bash_aliases
}
function unmark {
  sed -e "/^alias $1='cd/d" -i ~/Dropbox/Config/bash_aliases ; source ~/Dropbox/Config/bash_aliases
}
function marks {
  cat ~/Dropbox/Config/bash_aliases | grep "='cd" | sed -e 's/alias //' -e "s/='cd / \=\&gt; /" -e "s/'$//" -e "/^  echo /d" -e "/&amp;&amp;/d" -e "/^  sed/d"
}
</code></pre>

<!-- more -->


<p>This may not be the most elegant way of doing things (that sed command is fairly heinous) but it works great.</p>

<p>BTW keeping my bash_aliases file inside of dropbox is amazing&hellip;aliases and functions instantly appear on all my machines. It&rsquo;s rad.</p>

<p>P.S. originally I had the <code>unmark</code> command looking like this</p>

<pre><code>}
function unmark {
  sed -e "/^alias $1/d" -i ~/.bash_aliases ; source ~/.bash_aliases
}
</code></pre>

<p>which seems like a only minor modification from the current version. This seemingly minor change of <code>alias $1</code> -> <code>alias $1='cd</code> looks like nothing, but one time I accidentally typed
<code>
$mark
</code>
which created the line <code>alias ='cd ~/WhereverIWasWhenIDidThis'</code> in my <code>~/Dropbox/Config/bash_aliases</code>
realising I just made a empty alias I immediatly tried removing the alias with
<code>
$unmark
</code>
which proceded to delete all aliases in my <code>~/Dropbox/Config/bash_aliases</code>!!!
That was interesting, thank goodness for dropbox backing things up (another reason to keep config files in dropbox).
Let me know what you think in the comments or hit me up on twitter.</p>
]]></content>
  </entry>
  
</feed>
